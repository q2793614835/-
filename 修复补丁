buildscript {
repositories {
jcenter()
maven { url = "https://files.minecraftforge.net/maven " }
mavenCentral()
maven { url = "https://repo.spongepowered.org/maven " }
}
dependencies {
classpath "net.minecraftforge.gradle:ForgeGradle:2.3"
}
}

apply plugin: "net.minecraftforge.gradle.forge"

version = "1.0.0"
group = "com.example.safeinventoryguard"
archivesBaseName = "SafeInventoryGuard-1.12.2"

sourceCompatibility = 1.8
targetCompatibility = 1.8

minecraft {
version = "1.12.2-14.23.5.2860"
runDir = "run"
mappings = "stable_39"
}

repositories {
maven { url = "https://repo.spongepowered.org/maven " }
mavenCentral()
}

dependencies {
compileOnly "org.spongepowered:mixin:0.8.5"
annotationProcessor "org.spongepowered:mixin:0.8.5:processor"
}

jar {
manifest {
attributes(
"MixinConfigs": "safeinventoryguard.mixins.json"
)
}
}

processResources {
inputs.property "version", project.version
inputs.property "mcversion", project.minecraft.version

from(sourceSets.main.resources.srcDirs) {
include "mcmod.info"
expand "version": project.version, "mcversion": project.minecraft.version
}
from(sourceSets.main.resources.srcDirs) {
exclude "mcmod.info"
}
}

settings.gradle
rootProject.name = "SafeInventoryGuard-1.12.2"

gradle.properties（可选）
org.gradle.jvmargs=-Xmx2G

src/main/resources/mcmod.info
[
{
"modid": "safeinventoryguard",
"name": "SafeInventoryGuard",
"description": "Guards InventoryCrafting#setInventorySlotContents to prevent crashes on out-of-bounds writes.",
"version": "version","mcversion":" {mcversion}",
"url": "",
"authorList": ["you"],
"credits": "",
"logoFile": "",
"screenshots": [],
"dependencies": []
}
]

src/main/resources/safeinventoryguard.mixins.json
{
"required": true,
"minVersion": "0.8",
"package": "com.example.safeinventoryguard.mixin",
"compatibilityLevel": "JAVA_8",
"refmap": "safeinventoryguard.refmap.json",
"mixins": [
"MixinInventoryCrafting"
],
"client": [],
"server": []
}

src/main/java/com/example/safeinventoryguard/SafeInventoryGuardMod.java
package com.example.safeinventoryguard;

import net.minecraftforge.common.config.Configuration;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.File;

@Mod(modid = SafeInventoryGuardMod.MODID, name = "SafeInventoryGuard",
version = "1.0.0", acceptableRemoteVersions = "*", acceptedMinecraftVersions = "[1.12,1.13)")
public class SafeInventoryGuardMod {
public static final String MODID = "safeinventoryguard";
public static final Logger LOG = LogManager.getLogger("SafeInventoryGuard");

@Mod.EventHandler
public void preInit(FMLPreInitializationEvent e) {
File cfgFile = new File(e.getModConfigurationDirectory(), "SafeInventoryGuard.cfg");
Configuration cfg = new Configuration(cfgFile);
try {
cfg.load();
GuardConfig.enableGuard = cfg.getBoolean("enableInventoryCraftingGuard", "general", true,
"Enable guarding InventoryCrafting#setInventorySlotContents");
GuardConfig.logOncePerSession = cfg.getBoolean("logOncePerSession", "general", true,
"Log only once per server session when an out-of-bounds write is blocked");
} finally {
if (cfg.hasChanged()) cfg.save();
}
LOG.info("SafeInventoryGuard loaded. Guard enabled: {}, logOnce: {}",
GuardConfig.enableGuard, GuardConfig.logOncePerSession);
}
}

src/main/java/com/example/safeinventoryguard/GuardConfig.java
package com.example.safeinventoryguard;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.concurrent.atomic.AtomicBoolean;

public final class GuardConfig {
public static volatile boolean enableGuard = true;
public static volatile boolean logOncePerSession = true;

private static final AtomicBoolean loggedOnce = new AtomicBoolean(false);
private static final Logger LOG = LogManager.getLogger("SafeInventoryGuard");

public static boolean shouldLogNow() {
return !logOncePerSession || loggedOnce.compareAndSet(false, true);
}

public static String findTopCaller() {
StackTraceElement[] st = Thread.currentThread().getStackTrace();
for (StackTraceElement el : st) {
String c = el.getClassName();
if (c.startsWith("com.example.safeinventoryguard")) continue;
if (c.startsWith("org.spongepowered")) continue;
if (c.startsWith("net.minecraft.inventory.InventoryCrafting")) continue;
if (c.equals("java.lang.Thread")) continue;
return c + "." + el.getMethodName() + ":" + el.getLineNumber();
}
return "unknown";
}

public static void logBlocked(int index, int size) {
if (shouldLogNow()) {
LOG.warn("Blocked out-of-bounds InventoryCrafting.setInventorySlotContents: index={} size={}. Top caller: {}",
index, size, findTopCaller());
}
}

private GuardConfig() {}
}

src/main/java/com/example/safeinventoryguard/mixin/MixinInventoryCrafting.java
package com.example.safeinventoryguard.mixin;

import com.example.safeinventoryguard.GuardConfig;
import net.minecraft.inventory.InventoryCrafting;
import net.minecraft.item.ItemStack;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(InventoryCrafting.class)
public abstract class MixinInventoryCrafting {

@Shadow public abstract int getSizeInventory();

@Inject(method = "setInventorySlotContents(ILnet/minecraft/item/ItemStack;)V",
at = @At("HEAD"), cancellable = true)
private void sig$guardSetSlot(int index, ItemStack stack, CallbackInfo ci) {
if (!GuardConfig.enableGuard) return;
int size = this.getSizeInventory();
if (index < 0 || index >= size) {
GuardConfig.logBlocked(index, size);
ci.cancel();
}
}
}
